# Код, который умещается в голове

## Перечень методов

### П.1. Правило 50/72

Пишите простые сообщения коммитов Git:

- пишите заголовок в повелительном наклонении (**не более 50** символов);

- при добавлении дополнительного текста оставляйте следующую строку пустой;

- можно добавить любое количество дополнительного текста, но желательно отформатировать его так, чтобы его объем был **не более 72** символов.

После заголовка сосредоточьтесь и на объяснении *причины* внесения изменений, поскольку то, *какое* именно это изменение, уже видно через представление различий Git (`diff`). См. подраздел 9.1.1.

### П.2. Правило 80/24

Пишите небольшие блоки кода.

В языках программирования, основанных на C, таких как C#, Java, C++ или JavaScript, постарайтесь всегда придерживаться размера кода **80x24** символа. Этот размер соответствует старому окну терминала.

Не воспринимайте пороговые значения 80 и 24 слишком буквально.
Я выбрал их по трем причинам:

- они хорошо работают на практике;

- они отдают дань традициям;

- это правило подобно принципу Парето (принцип 80/20).

Вы можете выбрать другие пороговые значения. Я думаю, что самая важная часть этого правила - выбрать набор пороговых значений и постоянно оставаться в этих пределах.

Подробнее об этом - в подразделе 7.1.3.

### П.3. Шаблон Arrange-Act-Assert (AAA)

Структурируйте автотесты в соответствии с шаблоном Arrange-Act- Assert. Подробную информацию вы можете найти в подразделах 4.2.2 и 4.3.3.

### П.4. Бисекция

Метод бисекции поможет вам понять причину возникновения неполадки. Удалите половину вашего кода и проверьте, остался ли дефект. Как минимум вы уже будете знать, где именно искать причину.

Продолжайте сокращать код, пока не уменьшите его до минимального рабочего примера. На этом этапе вы удалили столько неважного кода, что причина проблемы наверняка станет ясна. Подробнее об этом - в разделе 12.3.

### П.5. Чек-лист для новой кодовой базы

При создании новой кодовой базы или добавлении нового проекта в существующую составьте чек-лист, например:

- использовать Git;

- автоматизировать сборку;

- включить все сообщения об ошибках.

Можете изменить чек-лист, чтобы он соответствовал вашему конкретному контексту. Но он должен оставаться кратким и простым. Подробную информацию вы можете найти в разделе 2.2.

### П.6. Разделение команд и запросов (CQS)

Отделяйте команды от запросов. *Команды* - это процедуры, име­ющие побочные эффекты, а *запросы* - функции, которые возвращают данные. Каждый метод должен быть либо командой, либо запросом, но не тем и другим одновременно. Подробнее об этом - в подразделе 8.1.6.

### П.7. Подсчет переменных

Подсчитывайте все переменные, участвующие в реализации метода. Включая локальные переменные, параметры метода и поля класса. Следите за тем, чтобы это число было небольшим. Подробную информацию вы можете найти в подразделе 7.2.7.

### П.8. Цикломатическая сложность

Цикломатическая сложность - одна из немногих действительно полезных метрик кода. С ее помощью можно подсчитать количество путей прохождения через фрагмент кода, тем самым получив представление о сложности метода.

Я считаю, что пороговое **значение 7** хорошо работает на практике. Вы можете выполнять полезную работу с цикломатической сложностью, равной **7**. Такой порог достаточно велик, чтобы не приходилось все время проводить рефакторинг, но все еще достаточно низок, чтобы метод умещался в вашей голове. Подробнее об этом - в подразделе 7.1.2.

Еще метрика предоставляет минимальное количество тестовых случаев, чтобы полностью охватить метод.

### П.9. Паттерн проектирования Decorator для сквозной функциональности

Не внедряйте зависимости логирования в свою бизнес-логику. Это не разделяет функциональность, а перемешивает все вместе. Это же касается кэширования, отказоустойчивости и большинства других сквозных задач.

Вместо этого используйте **паттерн декоратора**, описанный в разделе 13.2.

Примеры сквозного функционала:

- логирование;

- мониторинг производительности;

- аудиторская проверка;

- измерение;

- инструментирование;

- кэширование;

- отказоустойчивость;

- шаблон Circuit Breaker (прерыватель цепи);

- безопасность.

### П.10. Метод "Адвокат дьявола"

Метод «Адвокат дьявола» - это эвристика, которую вы можете использовать, чтобы оценить, укрепит ли большее количество тестов уверенность в тестовом наборе. Вы можете применять его для просмотра существующего (тестового) кода или использовать его в качестве вдохновения для новых тестовых случаев, которые нужно
добавить.

**Суть** в том, чтобы преднамеренно неправильно реализовать тестируемую систему. Чем более неверным вы можете сделать ответ, тем больше тестовых случаев вы должны добавить. Подробнее об этом в подразделе 6.2.2.

### П.11. Функциональный флаг

Если вы не можете внести последовательный набор изменений за
полдня, **скройте функцию за флагом** и продолжайте интегрировать
свои изменения с работой других специалистов.

Подробную информацию вы можете найти в разделе 10.1.

### П.12. Функциональное ядро, императивная оболочка

- Отдайте предпочтение **чистым функциям**.

- *Ссылочная прозрачность* означает, что вы можете заменить вызов
функции ее результатом без изменения поведения программы. Это предельная абстракция.

- Вывод инкапсулирует суть функции, в то время как все детали реализации остаются скрытыми (если они вам не нужны).

- Чистые функции хорошо компонуются, и их легко модульно тестировать.

Подробную информацию вы можете найти в подразделе 13.1.3.

### П.13. Иерархия отношений

Пишите код для разработчиков, которые будут иметь с ним дело. Когда- нибудь одним из таких можете оказаться и вы. Отдавайте предпочтение коммуникативному поведению и намерениям в соответствии с этим списком приоритетов.

1. Указывайте разные типы API.

2. Присваивайте методам полезные и понятные имена.

3. Пишите полезные комментарии.

4. Предоставляйте наглядные примеры в виде автотестов.

5. Пишите полезные сообщения коммитов в Git.

6. Создавайте полезную и понятную документацию.

Правила приведены в порядке убывания приоритета. Подробнее об
этом - в подразделе 8.1.7.

### П.14. Обоснование исключений из правил

Хорошие правила работают в большинстве случаев, но всегда есть исключения, когда правило только мешает. При необходимости можно отклониться от правила, но лишь обосновав и задокументировав причину. Подробную информацию вы можете найти в подразделе 4.2.3.

Это отличная возможность получить еще одно мнение, прежде чем
вы решите отклониться от правила. Иногда вы можете не обнаружить
подходящего способа получить желаемое и следовать правилу, но ваш
коллега может.

### П.15. Анализировать, а не проверять

Ваш код взаимодействует со остальным миром, а он не является объ-
ектно-ориентированным. Вместо этого вы получаете данные в виде
JSON, XML, значений, разделенных запятыми, буферов протоколов
или в других форматах, которые дают мало гарантий относительно
целостности данных.

По возможности всегда **старайтесь преобразовывать менее структурированные данные в более структурированные**. Вы можете думать об этом как о парсинге, даже если вы не анализируете обычный текст.

Подробнее об этом - в подразделе 7.2.5.

### П.16. Закон Постела

Помните о законе Постела для пред- и постусловий.

>«Будьте консервативны в том, что отправляете, и либеральны в том, что принимаете».

Методы должны принимать входные данные, до тех пор пока они
могут их осмыслить, но не более того. Возвращаемые значения должны быть максимально достоверными.

- Чем надежнее ваши гарантии и чем меньше вы требуете от другой стороны при заключении контракта, тем более привлекательным становится этот контракт.

Подробную информацию вы можете найти в подразделе 5.2.4.

### П.17. Цикл "красный, зеленый, рефакторинг"

При разработке через тестирование следуйте циклу «красный, зеле-
ный, рефакторинг». Предполагайте, что это чек-лист [93].

1. Напишите провальный тест.

- Вы провели тест?

- Провалился ли он?

- Провалился из-за утверждения?

- Провалился из-за последнего утверждения?

2. Сделайте все тесты успешными, выполнив самые простые изменения, которые только смогут работать.

3. Проанализируйте итоговый код. Можно ли его улучшить? Если да, сделайте это, но убедитесь, что тесты все еще проходят.

4. Повторите.

Подробнее об этом — в подразделе 5.2.2.

### П.18. Регулярное обновление зависимостей

Не позволяйте вашей кодовой базе отставать от зависимостей. Регулярно проверяйте наличие обновлений. Об этом легко забыть, и если пройдет слишком много времени с момента последнего обновления, вам может быть трудно наверстать упущенное.

Рекомендуется планировать в виде отдельных задач проверку и обновление версий зависимостей.

Подробнее об этом - в подразделе 14.2.1.

### П.19. Воспроизведение дефектов в виде тестов

По возможности воспроизведите ошибки в виде одного или несколь-
ких автоматизированных тестов. Подробную информацию вы можете
найти в подразделе 12.2.1.

### П.20. Код-ревью

При написании кода легко ошибиться. Попросите коллегу выполнить код-ревью. Оно не фиксирует все ошибки, но это один из самых эффективных методов обеспечения качества.

Вы можете выполнять код-ревью по-разному:

- постоянно

- при парном/моб-программировании

- асинхронно, через пул-реквесты.

При каждом проведении код-ревью отказ должен быть потенциальной опцией. Ревью ничего не стоит, если является лишь формальностью и проводится для галочки.

Введите код-ревью в свою ежедневную рутину. Подробнее об этом - в разделе 9.2.

### П.21. Семантическое версионироване

Рассмотрите возможность использования семантического версионирования. Подробную информацию вы можете найти в разделе 10.3.

В спецификации используется схема

`major.minor.patch`

Номера версий увеличиваются при:

- **Мажорной** версии - при внесении критических изменений.

- **Минорной** - при введении новой функциональности.

- **Патча** - при исправлении ошибки.

### П.22. Раздельный рефакторинг тестового и продакшен-кода

Автоматизированные тесты дают вам уверенность при рефакторинге продакшен-кода. Рефакторинг же тестового кода менее надежен из-за отсутствия у вас автотестов для тестов.

Это не значит, что вы вообще не можете выполнить рефакторинг тестового кода, но вы должны быть при этом предельно внимательны. Не проводите рефакторинг тестового и продакшен-кода одновременно.

При рефакторинге продакшен-кода не трогайте тестовый, и наоборот.

Подробную информацию вы можете найти в подразделе 11.1.3.

### П.23. Срез

Всегда разделяйте большие задачи на более мелкие. Каждое приращение должно улучшать рабочую систему. Начните с вертикального среза и добавьте к нему функциональность. Подробнее об этом - в главе 4.

Не рассматривайте этот процесс как исключительный. Я считаю, что это мой основной процесс продвижения вперед, но иногда нужно остановиться и заняться другими делами. Например, исправлением ошибок или работой над сквозной функциональностью.

### П.24. Паттерн Strangler

Некоторые рефакторинги выполняются быстро. Переименование переменной, метода или класса встроено в большинство IDE и выполняется одним нажатием кнопки. На некоторые изменения уходит несколько минут или часов. Пока вы можете перейти от одного согласованного состояния кодовой базы к другому менее чем за полдня, вам не понадобится делать ничего особенного.

Но есть изменения, которые имеют большое потенциальное влияние.
Я проводил рефакторинги, реализация которых занимала дни или
даже недели. Это не лучший способ работы.

Для внедрения таких изменений используйте паттерн **Strangler** (душитель). Установите новый способ работы параллельно со старым и постепенно переносите код со старого на новый.

Это может занять часы, дни или даже недели, но в процессе миграции
система всегда будет оставаться согласованной и интегрируемой.
Когда никакой код не вызывает исходный API, его можно удалить.

Подробнее об этом - в разделе 10.2.

### П.25. Модель угроз Stride

Принимайте осознанные решения в области безопасности.

Модель STRIDE достаточно проста в понимании для неэкспертов в области безопасности, поэтому вы можете легко с ней работать.

- Спуфинг (spoofing).

- Незаконное изменение (tampering).

- Отказ от авторства (repudiation).

- Раскрытие информации (information disclosure).

- Отказ в обслуживании (denial of service).

- Повышение привилегий (elevation of privilege).

При моделировании угроз должны участвовать ИТ-специалисты и другие заинтересованные стороны, поскольку надлежащее смягчение последствий обычно включает взвешивание бизнес-проблем и рисков безопасности.

Подробную информацию вы можете найти в подразделе 15.2.1.

### П.26. Предпосылки приоритета трансформации (TPP)

Старайтесь работать так, чтобы ваш код б**о**льшую часть времени находился в рабочем состоянии.

Преобразование одного допустимого состояния в другое обычно включает фазу, когда код недействителен, например когда он может не компилироваться.

TPP предлагают ряд небольших преобразований, которые минимизируют недопустимые этапы. Попытайтесь отредактировать свой код, внеся ряд этих небольших изменений.

Подробнее об этом - в подразделе 5.1.1.

### П.27. X-ориентированная разработка

Используйте *драйвер* (мотивирование для внесения изменений) для кода, который пишете.

Это может быть:

- включение рассмотрения предупреждений (warnings) как ошибок (errors)

- включение линтеров

- статический анализ кода

- модульное тестирование

- встроенные инструменты рефакторинга

- ...

Включая х-ориентированную разработку ПО, основанную на:

- разработке через тестирование [9] (TDD);

- разработке через поведение (BDD);

- предметно-ориентированном проектировании [26] (DDD);

- типоориентированной разработке;

- тестировании на основе свойств.

Можно отклоняться от этого правила, но чем чаще вы его придерживаетесь, тем меньше будет вероятность сбиться с верного пути.

Подробную информацию вы можете найти в разделе 4.2.

### П.28. Исключение имен

Замените имена методов символами `х`, чтобы проверить количество передаваемой сигнатурой метода информации. Можно сделать это в уме. Это не обязательно делать в вашем редакторе, так как в статически типизированном языке типы могут нести очень много информации. Подробнее об этом — в подразделе 8.1.5.

## Ссылки

82. Poppendieck M., Poppendieck T. Implementing Lean Software Development: From Concept to Cash. Addison-Wesley, 2006.

83. Preston-Werner T. Semantic Versioning. Спецификация по адресу https://semver.org.
На момент написания книги (октябрь 2020 года) последней версией была Semantic Versioning 2.0.0.

84. Five Years of Mob Testing, Hello to Ensemble Testing

Пост в блоге: https://visible-quality.blogspot.com/2020/05/five-years-of-mob-testinghello-to.html

85. Rainsberger J. B. Integration Tests Are a Scam, Agile 2009 conference talk, 2009.

Запись доступна по адресу https://www.infoq.com/presentations/integration-tests-scam

86. Rainsberger J. B. Твит: https://twitter.com/jbrains/status/167297606698008576

87. Reeves J. What Is Software Design? // C++ Journal, 1992

Статья: https://www.developerdotstar.com/mag/articles/reeves_design.html
Также есть и в виде приложения в [60].

88. Рис Э. Бизнес с нуля: Метод Lean Startup для быстрого тестирования идей и выбора бизнес-модели. - М .: Альпина Паблишер, 2022.

89. Робинсон Я., Эифрем Э., Вебер Дж . Графовые базы данных . Новые возможности для работы. - М .: ДМК-Пресс, 2016.

90. Scott J. C. Seeing Like a State: How Certain Schemes to Improve the Human Condition Have Failed. Yale University Press, 1998.

91. Seemann M. 10 tips for better Pull Requests.

Пост в блоге: https://blog.ploeh.dk/2015/01/15/10-tips-for-better-pull-requests

[Original](/doc/091/original.md), [Adapted](/doc/091/adapted.md)

91.1. http://en.wikipedia.org/wiki/Single_responsibility_principle

91.2. Is the 80 character line limit still relevant?

http://richarddingwall.name/2008/05/31/is-the-80-character-line-limit-still-relevant

[Original](/doc/091_2/original.md), [Adapted](/doc/091_2/adapted.md)

91.3. http://xunitpatterns.com/Humble%20Object.html

91.4. http://butunclebob.com/ArticleS.TimOttinger.ApologizeIncode

91.5. Seemann M. The programmer as decision maker

https://blog.ploeh.dk/2019/03/18/the-programmer-as-decision-maker

92. Seemann M. A heuristic for formatting code according to the AAA pattern.

Пост в блоге: https://blog.ploeh.dk/2013/06/24/a-heuristic-for-formatting-code-according-to-the-aaa-pattern/

[Original](/doc/092/original.md), [Adapted](/doc/092/adapted.md)

92.1. Tim Ottinger - Apologies In Code

http://butunclebob.com/ArticleS.TimOttinger.ApologizeIncode

[Original](/doc/092_1/original.md), [Adapted](/doc/092_1/adapted.md)

92.1.1. To Need Comments

https://wiki.c2.com/?ToNeedComments

92.2. Seemann M. Zone of Ceremony

https://blog.ploeh.dk/2019/12/16/zone-of-ceremony/

[Original](/doc/092_2/original.md), [Adapted](/doc/092_2/adapted.md)

92.2.1. Venkat Subramaniam explains ceremony

https://youtu.be/4jCjDEb9KZI

92.2.2. Seemann M. An F# implementation of the Maître d' kata

https://blog.ploeh.dk/2020/04/27/an-f-implementation-of-the-maitre-d-kata/

92.3. Seemann M. C# will eventually get all F# features, right?

https://blog.ploeh.dk/2015/04/15/c-will-eventually-get-all-f-features-right/

[Original](/doc/092_3/original.md)

92.3.1. Seemann M. SOLID: the next step is Functional

https://blog.ploeh.dk/2014/03/10/solid-the-next-step-is-functional/

92.3.2. Seemann M. Less is more: language features

https://blog.ploeh.dk/2015/04/13/less-is-more-language-features

92.3.3. Cycles and modularity in the wild

https://fsharpforfunandprofit.com/posts/cycles-and-modularity-in-the-wild/

92.3.4. Comparing F# and C# with dependency networks

https://evelinag.com/blog/2014/06-09-comparing-dependency-networks/

93. Seemann M. A red-green-refactor checklist

Пост в блоге: https://blog.ploeh.dk/2019/10/21/a-red-green-refactor-checklist

[Original](/doc/093/original.md)

93.1. Fizz buzz

https://en.wikipedia.org/wiki/Fizz_buzz

93.2. Seemann M. Tautological assertion

https://blog.ploeh.dk/2019/10/14/tautological-assertion

93.3. Seemann M. Devil's advocate

https://blog.ploeh.dk/2019/10/07/devils-advocate/

94. Seemann M. Church-encoded Maybe

Пост в блоге: https://blog.ploeh.dk/2018/06/04/church-encoded-maybe

[Original](/doc/094/original.md)

94.1. Seemann M. Church encoding

https://blog.ploeh.dk/2018/05/22/church-encoding

94.2. Seemann M. Church-encoded Boolean values

https://blog.ploeh.dk/2018/05/24/church-encoded-boolean-values

94.3. Seemann M. Church-encoded natural numbers

https://blog.ploeh.dk/2018/05/28/church-encoded-natural-numbers

94.4. Tagged union

https://en.wikipedia.org/wiki/Tagged_union

94.5. Tony Hoare

https://en.wikipedia.org/wiki/Tony_Hoare

94.6. Seemann M. The Maybe functor

https://blog.ploeh.dk/2018/03/26/the-maybe-functor

94.7. Parametric polymorphism

https://en.wikipedia.org/wiki/Parametric_polymorphism

94.8. Lambda calculus

https://en.wikipedia.org/wiki/Lambda_calculus

94.9. Scrap Your Constructors: Church Encoding Algebraic Types

http://programmable.computer/posts/church_encoding.html

94.10. Seemann M. Software design isomorphisms

https://blog.ploeh.dk/2018/01/08/software-design-isomorphisms

94.11. Seeman M. Null has no type, but Maybe has

https://blog.ploeh.dk/2015/11/13/null-has-no-type-but-maybe-has

94.12. Seeman M. Functors

https://blog.ploeh.dk/2018/03/22/functors

94.13. Seeman M. Church-encoded Either

https://blog.ploeh.dk/2018/06/11/church-encoded-either

94.14. Seeman M. Argument list isomorphisms

https://blog.ploeh.dk/2018/01/29/argument-list-isomorphisms/

94.15. HaskellWiki. Performance/Strictness

https://wiki.haskell.org/Performance/Strictness

94.16. Seeman M. The Lazy applicative functor

https://blog.ploeh.dk/2018/12/17/the-lazy-applicative-functor

94.17. Seeman M. The Lazy functor

https://blog.ploeh.dk/2018/09/10/the-lazy-functor

95. Seemann M. CQS versus server generated Ids

Пост в блоге: https://blog.ploeh.dk/2014/08/11/cqs-versus-server-generated-ids

96. Seemann M. Conway’s Law: latency versus throughput

Пост в блоге: https://blog.ploeh.dk/2020/03/16/conways-law-latency-versus-throughput

97. Seemann M. Curb code rot with thresholds

Пост в блоге: https://blog.ploeh.dk/2020/04/13/curb-code-rot-with-thresholds

98. Seemann M. Devil’s advocate

Пост в блоге: https://blog.ploeh.dk/2019/10/07/devils-advocate

99. Seemann M. Feedback mechanisms and tradeoffs

Пост в блоге:https://blog.ploeh.dk/2011/04/29/Feedbackmechanismsandtradeoffs

100. Seemann M. From interaction-based to state-based testing

Пост в блоге: https://blog.ploeh.dk/2019/02/18/from-interaction-based-to-state-basedtesting

101. Seemann M. Fortunately, I don’t squash my commits

Пост в блоге: https://blog.ploeh.dk/2020/10/05/fortunately-i-dont-squash-my-commits

102. Seemann M. Functional architecture is Ports and Adapters

Пост в блоге: https://blog.ploeh.dk/2016/03/18/functional-architecture-is-ports-and-adapters

103. Seemann M. Repeatable execution

Пост в блоге: https://blog.ploeh.dk/2020/03/23/repeatable-execution

104. Seemann M. Structural equality for better tests

Пост в блоге: https://blog.ploeh.dk/2021/05/03/structural-equality-for-better-tests

105. Seemann M. Tautological assertion

Пост в блоге: https://blog.ploeh.dk/2019/10/14/tautological-assertion

106. Seemann M. Towards better abstractions

Пост в блоге: https://blog.ploeh.dk/2010/12/03/Towardsbetterabstractions

107. Seemann M. Visitor as a sum type

Пост в блоге: https://blog.ploeh.dk/2018/06/25/visitor-as-a-sum-type

[Original](/doc/107/original.md)

108. Seemann M. When properties are easier than examples

Пост в блоге: https://blog.ploeh.dk/2021/02/15/when-properties-are-easier-than-examples

109. Шоу Дж. Ложная память. Почему нельзя доверять воспоминаниям. - М .: Колибри, 2017.

110. Thomas N., Murphy G. How Effective Is Modularization? / В [75], 2010 .

111. Tornhill A. Your Code as a Crime Scene: Use Forensic Techniques to Arrest Defects, Bottlenecks and Bad Design in Your Programs. Pragmatic Bookshelf, 2015.

112. Tornhill A. Software Design X-Rays: Fix Technical Debt with Behavioral Code Analysis. Pragmatic Bookshelf, 2018 .

113. Troy C. Reviewing Pull Requests

Пост в блоге: https://chelseatroy.com/2019/12/18/reviewing-pull-requests

114. Webber J. Savas Parastatidis and Ian Robinson. REST in Practice: Hypermedia and Systems Architecture. O’Reilly, 2010.

115. Weinberg G. M. The psychology of computer programming. Silver anniversary edition. Dorset House Publishing, 1998.

116 . Williams L. Pair Programming в [75], 2010.

117 . Wlaschin S. Cycles and modularity in the wild

Пост в блоге: https://fsharpforfunandprofit.com/posts/cycles-and-modularity-in-the-wild

118 . Woolf B. Null Object / В [62], 1997.
